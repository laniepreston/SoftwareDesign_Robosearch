// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ROBOSEARCH;
/* import from package */
import ROBOSEARCH.Coordinate;
import ROBOSEARCH.Observer;
import ROBOSEARCH.Task;
import ROBOSEARCH.CentralStation;
import ROBOSEARCH.Subject;
import ROBOSEARCH.mode;
/*import from simbad */
import simbad.sim.Agent;
import simbad.sim.RangeSensorBelt;
import simbad.sim.RobotFactory;
import simbad.sim.CameraSensor;
/* import from java */
import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.util.ListIterator;

public class Rover extends Agent implements Observer {

	/**
	 * 
	 */
	private int id;
	/**
	 * 
	 */
	private Subject subject;
	/**
	 * 
	 */
	private Point3d myPoint;
	/**
	 * 
	 */
	private RangeSensorBelt sonars;
	/**
	 * 
	 */
	private CameraSensor camera;
	/**
	 * 
	 */
	private BufferedImage image;
	/**
	 * 
	 */
	private Task task;
	
	/**
	 * 
	 */
	private Coordinate currentLocation;
	/**
	 * 
	 */
	private mode currentMode;
	/**
	 * 
	 */
	private boolean hasRotatedLeft = false;
	/**
	 * 
	 */
	private int numberOfLeftRotations = 0;
	/**
	 * 
	 */
	private boolean hasRotatedRight = false;
	/**
	 * 
	 */
	private int numberOfRightRotations = 0;
	/**
	 * 
	 */
	private Color[] searchColors;
	/**
	 * 
	 */
	private int avoidObstacleStep = 0;
	/**
	 * 
	 */
	private boolean hasFoundBox;
	/**
	 * 
	 */
	private orientation myOrientation;
	/**
	 * 
	 */
	ListIterator<Coordinate> iterator;

	/**
	 * this method is called once at the beginning of the rover's life 
	 */
	public void initBehavior() {
		System.out.println("----------------------------------------");
		System.out.println("Hello I am a searching rover and my id is " + id);
		System.out.println("----------------------------------------");
		// Initial State
		this.currentMode = mode.FOLLOW_PATH;
		this.initOrientation(this.myOrientation);
	}

	/**
	 * Perform the following actions every 20 virtual seconds  20 counters -- 1 second
	 */
	public void performBehavior() {	
		if (this.getCounter() % 20 == 0) {
			
			this.currentLocation = getCurrentLocation();
			this.updatePath();
			
			switch(this.currentMode){
			case AVOID_OBSTACLE:
				this.avoidObstacles();
				break;
			case FOLLOW_PATH:
				this.followPath();
				break;
			case IDLE:
				break;
			default:
				break;
			}
		}
	}
	/**
	 * 
	 */
	private void followPath(){
		this.moveAhead();
		
		if(this.sonarHasHit() && Math.round(this.getDistanceBySonar()) <= 1.5){
			this.currentMode = mode.AVOID_OBSTACLE;
			this.takePhoto();
			Color colorPhoto = this.determineColor(this.singleColor(image));
			if(this.checkIfBox(colorPhoto)){
				this.hasFoundBox = true;
				if(colorPhoto == this.task.getSearchColor()){
					System.out.println("Rover " + this.id +" found a box of searchcolor");
					
					this.updateTask(this.currentLocation);
				}
			}
		}
		
	}
	
	/**
	 * Implementation on how to avoid obstacles
	 */
	private void avoidObstacles() {
		if(this.hasFoundBox){
			
			// go to right, left, left, right
			switch(this.avoidObstacleStep){
				case 0:
					this.rotateQuarter(false);
					this.avoidObstacleStep++;
					break;
				case 1:
					this.rotateQuarter(true);
					this.avoidObstacleStep++;
					break;
				case 2:
					this.moveAhead();
					this.avoidObstacleStep++;
					break;
				case 3:
					this.rotateQuarter(true);
					this.avoidObstacleStep++;
					break;
				case 4:
					this.rotateQuarter(false);
					this.avoidObstacleStep++;
					break;
				case 5:
					this.moveAhead();
					this.avoidObstacleStep = 0;
					this.hasFoundBox = false;
					this.currentMode = mode.FOLLOW_PATH;
					break;
			}
			
		}else{
			if(this.numberOfRightRotations == 0){
				this.rotateQuarter(false);				
			}
			else if(this.numberOfRightRotations % 2 != 0){
				this.rotateQuarter(false);
				this.currentMode = mode.FOLLOW_PATH;
			}
			else if(this.numberOfRightRotations % 2 == 0 && this.hasRotatedRight){
				this.rotateQuarter(true);
			}
			else if(this.numberOfLeftRotations == 0){
				this.rotateQuarter(true);
			}
			else if(this.numberOfLeftRotations % 2 != 0){
				this.rotateQuarter(true);
				this.currentMode = mode.FOLLOW_PATH;
			}
			else if(this.numberOfLeftRotations %2 == 0 && this.hasRotatedLeft){
				this.rotateQuarter(false);
			}
		}
		
	}
	
	/**
	 * TODO: still buggy, needs some work. however deadline is in 2 hours
	 */
	private void updatePath(){
		this.iterator = this.task.getPath().listIterator();
		
		while(this.iterator.hasNext()){
			Coordinate current = iterator.next();
			if(current.getLatitude() == this.currentLocation.getLatitude() && current.getLongitude() == this.currentLocation.getLongitude()){
				current.setCoordinateHasBeenVisited();
				return;
			}
		}
	}
	/**
	 * 
	 */	
	private void setOrientationQuarter(boolean left){
		switch(myOrientation){
		case EAST:
			if(left)
				myOrientation = orientation.NORTH;
			else
				myOrientation = orientation.SOUTH;
			break;
		case NORTH:
			if(left)
				myOrientation = orientation.WEST;
			else
				myOrientation = orientation.EAST;
			break;
		case SOUTH:
			if(left)
				myOrientation = orientation.EAST;
			else
				myOrientation = orientation.WEST;
			break;
		case WEST:
			if(left)
				myOrientation = orientation.SOUTH;
			else
				myOrientation = orientation.NORTH;
			break;
		default:
			break;
		
		}
	}
	

	/**
	 * set speed to zero
	 */
	private void stop() {
		this.setTranslationalVelocity(0);							
		this.setRotationalVelocity(0);						
	}

	/**
	 * Let the rover stop rotating and move ahead.
	 */
	private void moveAhead() {
		//System.out.println("move ahead");
		this.setRotationalVelocity(0);
		this.setTranslationalVelocity(1);
	}

	/**
	 * 
	 * @param left 
	 */
	private void rotateQuarter(boolean left) {

		if(left){
			this.rotateY(Math.PI/2);
			this.hasRotatedLeft = true;
			this.hasRotatedRight = false;
			this.setOrientationQuarter(left);
			this.numberOfLeftRotations++;
			
		}else{
			this.rotateY(-Math.PI/2);	
			this.hasRotatedRight = true;
			this.hasRotatedLeft = false;
			this.setOrientationQuarter(!left);
			this.numberOfRightRotations++;
		}
	}

	/**
	 * returns the current location of the rover
	 * @return         
	 */
	public Coordinate getCurrentLocation() {
		getCoords(myPoint);
		int xCoord = (int) Math.round(myPoint.x);
		int zCoord = (int) Math.round(myPoint.z);
		Coordinate currentLocation = new Coordinate(zCoord, xCoord);
		return currentLocation;
	}

	@Override
	public void update() {
		int state = this.subject.getState();
		if(state == 0){
			//TODO: add implementation for rover when cs is in state 0
		}
		// The simulation has run its maximum time
		else if (state == 1){
			this.currentMode = mode.IDLE;
			stop();
		} 		
	} 
	
	
	/**
	 * 
	 * @param foundBlock 
	 */
	private void updateTask(Coordinate foundBlock) {
		this.task.addFoundBlock(foundBlock);
	}

	/**
	 * 
	 */
	private void takePhoto() {
		camera.copyVisionImage(this.image);	
	}

	/**
	 * 
	 * @param position 
	 * @param name 
	 * @param task 
	 */
	public Rover(String name, Task task, Color[] searchColors) {
		super(new Vector3d(task.getStartPosition().getLatitude(),0,task.getStartPosition().getLongitude()), name);
		this.id = Integer.parseInt(name);
		this.subject = CentralStation.getInstance();
		this.subject.attach(this);
		this.myPoint = new Point3d();
		
		this.sonars = RobotFactory.addSonarBeltSensor(this, 1);
	    this.camera = RobotFactory.addCameraSensor(this);
	    this.image = camera.createCompatibleImage();
	    
	    this.task = task;
	    this.searchColors = searchColors;
	    
	    this.myOrientation = task.getStartOrientation();
	    this.iterator = this.task.getPath().listIterator();
	}
	
	/**
	 * Checks if object is one of the search colors. It is then assumed that boxes only have one of the searching colors
	 * and the walls don't have one of the searching colors
	 * @return  
	 */
	private boolean checkIfBox(Color colorObject){
		for(int i = 0; i < this.searchColors.length; i++){
			if(colorObject == this.searchColors[i]){
				return true;
			}
		}
		return false;
	}

	/**
	 * implementation if we know image only contains the block/single pixel
	 * @return  
	 * @param image  
	 */
	private Color singleColor(BufferedImage image) {
		 //get the middle pixel as this has the highest probability of containing the box
		int x=image.getHeight()/2, y=image.getWidth()/2;
		return new Color(image.getRGB(x,y));
		
	}

	/**
	 * gives the color options red, green, blue, yellow, otherwise a white wall we then need a boolean function to know if it's a green or blue block within task/rovers?
	 * @param color  
	 * @return  
	 */
	private Color determineColor(Color color) {
		int red = color.getRed();
		int blue = color.getBlue();
		int green = color.getGreen();
		
		//determines approximate color based on color values 
		if(red - (blue + green) > 100) {
			return Color.red;
		}
		
		else if(blue - (red+green) > 100) {
			return Color.blue;
		}
		
		else if(green - (red + blue) > 100) {
			return Color.green;
		}
		
		else if((red - green) < 100) {
			return Color.yellow;
		}
		//at this moment "black" for other colors
		return Color.black;
	}

	/**
	 * returns true if a rover's sonar has hit an obstacle and updates sonarId
	 * @return  
	 */
	private boolean sonarHasHit() {
		boolean hasHit = false;
		for (int i = 0; i< sonars.getNumSensors(); i++) {
			boolean hit = sonars.hasHit(i);
			
			if(hit){
				//System.out.println("sonar " + i + " has hit something");
				hasHit = hit;
				break;
			}
		}
		return hasHit;
	}

	/**
	 * 
	 * @return 
	 */
	private double getDistanceBySonar() {
		double range = 0.0;
		// there is no getSonarById method in RangeSensorsBelt class, so we have to loop all the sonars, in order to get the distance
		for (int i=0;i< sonars.getNumSensors();i++) {
			
			range = sonars.getMeasurement(i); 
			
			if (range != Double.POSITIVE_INFINITY){
				//System.out.println("Sonar at angle "+ angle + "measured range =" + range);
			}
	    }
		return range;
	}

	/**
	 * 
	 */	
	private void initOrientation(orientation startOrientation){
		// default orientation is EAST
		switch(startOrientation){
		case WEST:
			this.rotateY(-Math.PI);
			break;
		case NORTH:
			this.rotateY(-Math.PI/2);
			break;
		case SOUTH:
			this.rotateY(Math.PI/2);
			break;
		default:
			break;		
		}
	}
	
	/**
	 * 
	 */	
	public boolean finishedTask(){
		return this.task.isFinished();
	}
};